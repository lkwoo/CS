# Hash
- Node : Key와 Value를 함께 저장. Key로 데이터를 저장하고 찾는다.
- Hashcode = Hash(Key)
- Index = Hashcode % N (N은 임의로 설정한다)

|Key       |Hashcode  |Index     |List              |
|----------|----------|----------|------------------|
|"Sung"    |445       |0         |jin -> hee -> min |
|"jin"     |321       |1         |sung              |
|"hee"     |306       |2         |                  |
|"min"     |324       |..        |                  |

- Hashcode를 거쳐 Index를 구하는데, Index를 잘 분산시키는 Hash가 좋은 Hash다.

## 충동(Collision)에 대한 대처
1. Chaining : 같은 index가 나오면 리스트로 연결한다.
    - 장점
        1. 한정된 저장소(Bucket)을 효율적으로 사용
        2. Hash Function을 선택하는 중요성이 상대적으로 적다.
        3. 상대적으로 적은 메모리를 사용한다. 미리 공간을 잡아 놓을 필요가 없다.

    - 단점
        1. 한 Hash에 자료들이 계속 연결된다면(쏠림 현상) 검색 효율을 낮출 수 있다.
        2. 외부 저장 공간을 사용한다.
        3. 외부 저장 공간 작업을 추가로 해야 한다.

2. Open Addressing : 그냥 다음 빈칸에 저장.
    - 장점
        1. 또 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능하다.
        2. 또 다른 저장공간에서의 추가적인 작업이 없다.
    - 단점
        1. 해시 함수(Hash Function)의 성능에 전체 해시테이블의 성능이 좌지우지된다.
        2. 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해 두어야 한다.
  
## Q & A
1. 적절한 Hash Table의 크기는 얼마일까?
    - N개의 데이터를 다룬다면 약 1.3N을 추천(실험해보니 1.3배가 적절하다더라)
2. Hash Table에 Mapping 할 때, 왜 소수로 나눠야 할까? 확률은 같지 않나?
    - Hash 함수의 동작 방식에 따라 다른데, 각 문자열의 아스키코드값에 K의 i승을 곱한 후 더해나가는 방식도 있습니다.
    - 이러한 방식을 사용할 때, Mod 연산을 하는(Hash Table로 mapping하기 위한) 숫자 M이 K와 서로소가 아니라면 특정 Index에서 해쉬 충돌이 발생할 가능성이 큽니다.
    - 따라서 Hash 함수의 내부 동작을 모른다면, Prime Number를 사용하는 것이 좋습니다.

----------------------------------
# Sort
- 데이터를 주어진 기준에 맞게 재배치하는 알고리즘
## O(N^2) Sort
### Bubble Sort
- **안정 정렬, In-Place 정렬**
- 웬만하면 최악인 정렬. Swap 연산을 많이 함
- 그러나 정렬된 상태라면 O(N)으로 끝남
- 라이브러리로 이쁘게 만들어 줘도 안 씀
  
``` c
void bubble_sort(int A[], int N){  // asc order
  bool flag; // 정렬 완료시 바로 끝내기
  for(int i=N-1; i > 0; i--){
    flag = 0;
    for(int j=0; j < i; j++){      
      if(A[j] > A[j+1]){
        flag = 1;
        int tmp = A[j];
        A[j] = A[j + 1];
        A[j + 1] = tmp;
      }
    }
    if(!flag) return;
  }
}
```
### Insertion Sort
- **안정 정렬, In-Place 정렬** 
- 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입
- 실생활에서 사람들이 자주 사용하는 정렬
- O(N^2) 정렬 알고리즘 중에선 빠른 편
- Quick Sort의 성능 향상을 위해 말단 정렬(N < 200 정도)에 사용되기도 한다.
  
``` c
void insertion_sort(int A[], int N){  // asc order
  int j, i, tmp;
  for(j = 1; j < N; j++){
    tmp = A[j];
    for(i=j - 1; i >= 0 && A[i] > tmp; i--) // A[i] < tmp 로 바꾸면 내림차순
      A[i + 1] = A[i];
    A[i + 1] = tmp;
  }
}
```
### Selection Sort
- **불안정 정렬, In-Place 정렬** 
- 가장 작은(or 큰) 값을 선택해 차례로 정렬한다
  
``` c
void selection_sort(int A[], int N){  // asc order  
  for(int j = 0; j < N; j++){
    int tmp = j;
    for(int i=j + 1; i < N; i++)
      if(A[tmp] > A[i]) // A[tmp] < A[i] 로 바꾸면 내림차순
        tmp = i;
    swap(A[tmp], A[j]);
  }
}
```
## O(NlogN) Sort
### Quick Sort
- h
### Merge Sort
### Heap Sort
## Others

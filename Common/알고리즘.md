# Hash
- Node : Key와 Value를 함께 저장. Key로 데이터를 저장하고 찾는다.
- Hashcode = Hash(Key)
- Index = Hashcode % N (N은 임의로 설정한다)

|Key       |Hashcode  |Index     |List              |
|----------|----------|----------|------------------|
|"Sung"    |445       |0         |jin -> hee -> min |
|"jin"     |321       |1         |sung              |
|"hee"     |306       |2         |                  |
|"min"     |324       |..        |                  |

- Hashcode를 거쳐 Index를 구하는데, Index를 잘 분산시키는 Hash가 좋은 Hash다.

## 충동(Collision)에 대한 대처
1. Chaining : 같은 index가 나오면 리스트로 연결한다.
    - 장점
        1. 한정된 저장소(Bucket)을 효율적으로 사용
        2. Hash Function을 선택하는 중요성이 상대적으로 적다.
        3. 상대적으로 적은 메모리를 사용한다. 미리 공간을 잡아 놓을 필요가 없다.

    - 단점
        1. 한 Hash에 자료들이 계속 연결된다면(쏠림 현상) 검색 효율을 낮출 수 있다.
        2. 외부 저장 공간을 사용한다.
        3. 외부 저장 공간 작업을 추가로 해야 한다.

2. Open Addressing : 그냥 다음 빈칸에 저장.
    - 장점
        1. 또 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능하다.
        2. 또 다른 저장공간에서의 추가적인 작업이 없다.
    - 단점
        1. 해시 함수(Hash Function)의 성능에 전체 해시테이블의 성능이 좌지우지된다.
        2. 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해 두어야 한다.

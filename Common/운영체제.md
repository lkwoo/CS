## Contents
### 1. [Process와 Thread](#process와-thread)
### 2. [Process Scheduling](#process-scheduling)


----------------------------------------------------------------------------
# Process와 Thread
## Process
- 실행중인 프로그램
- 커널에 등록되고 커널의 관리하에 있는 작업
- 프로세스 관리 블록(PCB)을 할당 받은 개체

### Process의 종류
1. System(Kernel) Process
2. User Process
3. 독립 Process
4. 협력 Process

### Resource의 개념
- Kernel의 관리 하에 Process에게 할당/반납되는 수동적 개체
- HW : Processor, Memory, disk Monitor...
- SW : Message, Signal, Files...

### Process Control Block : PCB
- OS가 process 관리에 필요한 정보 저장
- Process 생성 시, 함께 만들어짐
- 관리하는 정보
    1. PID : Process 고유 식별 번호
    2. Scheduling 정보 : Process 우선순위 등과 같은 스케쥴링에 필요한 정보
    3. Process 상태 : 자원 할당 정보 등
    4. Memory 관리 정보 : Page table, segment table 등
    5. I/O 상태 정보 : 입출력 장치, 파일 등에 대한 정보
    6. Context 저장 영역 : Process Register 상태를 저장하는 공간 등
    7. 계정 정보
- PCB는 OS 마다 다를 수 있다.
- PCB 참조 및 갱신속도는 OS의 성능을 결정 짓는 중요한 요소 중 하나

### Process States
1. Created State
    - 작업을 터널에 등록
    - PCB 할당 및 Process 생성
    - Memory 할당 받으면 Ready , 아니면 Suspended Ready
2. Ready State
    - Processor 이외의 모든 자원을 할당 받은 상태
    - Running State가 되는 것을 Dispatch or Schedule이라고 표현
3. Running State
    - Processor와 필요한 자원을 모두 할당 받은 상태
    - Preemption : Running -> Ready. Process Scheduling Time out
    - Block/sleep : I/O 자원 대기
4. Blocked/Asleep State
    - Processor 외의 다른 자원을 기다리는 상태. 자원할당은 System Call에 의해 이루어짐
5. Suspended State
    - Memory를 할당 받지 못한 상태
    - Memory Image를 Swap Device에 저장
6. Terminated/Zombie State
    - Process 작업이 끝난 상태
    - 모든 자원 반납
    - Kernel에 PCB의 일부 정보만 남아 있다.

- Ready Queue
- I/O Queue
- Device Queue

### Context Switching
- Context : 문맥. Process와 관련된 정보의 집합
    - CPU register context : CPU
    - Code, Data, Stack, PCB : Memory
- Context Saving : 현재 프로세스의 Register Context를 저장하는 작업
- Context Restoring : Register Context를 Process로 복구하는 작업
- Context Switching : 실행 중인 Process의 Saving과 앞으로 실행할 Process의 Restoring 작업
- 불필요한 Switching을 줄이는 것이 중요하다 -> Thread

## Thread
- Thread : Process에서 자원을 제외한 제어부만을 나타냄  
- Process(제어정보 sp pc 등, 지역데이터, 스택), Resource(코드, 전역데이터, 힙)
- Light Weight Process
- Processor 활용의 기본 단위
- 구성 요소
    - Thread ID
    - Register Set(PC, SP)
    - Stack(Local Data)
- 제어 요소 외의 코드, 데이터 및 자원들은 프로세스 내 다른 스레드들과 공유

### Thread의 장점
  - 사용자 응답성(Responsiveness) : 일부 스레드의 처리가 지연되어도, 다른 스레드는 작업을 계속 처리 가능
  - 자원공유(Resource Sharing) : 자원을 공유해서 효율성 증가. Kernel 개입 최소화
  - 경제성(Economy) : Process의 생성, Context Switching에 비해 효율적
  - 멀치 프로세서(Multi-Processor)활용 : 병렬처리를 통해 성능 향상 
### 사용자 수준 스레드(User Thread)
  - 사용자 영역의 스레드 라이브러리로 구현됨
  - 스레드의 생성, 스케줄링 등
  - POSIX Threads, Win32 Threads, JAVA Thread API 등\
  - 커널은 Thread의 존재를 모름, Process가 Block 되면 모든 Thread 대기
### Kernel 수준 스레드(Kernel Thread)
  - OS가 직접 관리
  - Kernel 영역에서 스레드의 생성, 관리 수행. Context Switching 등 Overhead가 큼
  - Kernel이 각 Thread를 개별적으로 관리
### Multi-Thread 
  - 혼합형 N:M. N개의 사용자스레드 M개의 커널스레드. N >= M 
--------------------------------------------------------------------------------
 
# Process Scheduling
## Process Scheduling 목적
- 한정된 자원, 여러 개의 프로세스. 자원을 할당할 프로세스를 선택해야 한다.
- 시스템의 성능(Performance) 향상
- 대표적인 성능 지표
    - 응답시간(Response Time) : 작업 요청으로부터 응답을 받을 때까지의 시간
        - 대화형 시스템, Real-Time 시스템
    - 작업 처리량(Throughput) : 단위 시간 동안 완료된 작업의 수
        - 일괄 처리 시스템
    - 자원 활용도(Resource Utilization) : 주어진 시간 동안 자원이 활용된 시간
        - 비싼 장비 활용
- 목적에 맞는 지표를 고려해 스케줄링 해야한다.

## Scheduling Criteria
- 프로세스의 특성 : I/O
- 시스템 특성 : interactive or batch

## Scheduling Level
### Long-Term Scheduling
- Job Scheduling : 커널에 등록할 작업 결정
- 다중프로그래밍 정도 조절 : 시스템 내의 프로세스 수 조절
- I/O Bounded와 Compute-Bounded 프로세스들을 잘 섞어서 선택
- 시분할 시스템에서는 모든 작업을 시스템에 등록 : Long-Term 에서는 취급 안해

### Mid-Term Scheduling
- Memory Allocation 결정

### Short-Term Scheduling
- Process Scheduling : Processor에 할당할 Process를 결정
- 가장 빈번하게 발생
- 매우 빨라야 한다

### Scheduling Policy
- 선점 vs 비선점
    - Non-Preemptive
        - 할당 받은 자원을 스스로 반납할 때까지 사용
        - Context Switching Overhead가 적음
        - 평균 응답시간 증가
    - Preemptive
        - 타의에 의해 자원을 뻇길 수 있음 : 할당 시간 종료, 높은 우선순위 등장
        - Context Switching Overhead가 큼
        - 시분할, 실시간 시스템에 적합
- 우선순위
    - Static Priority
        - 프로세스 생성시 결정. 구현 쉬움.
    - Dynamic Priority
        - 상황에 따라 우선순위 변동. 구현 복잡. 유연한 대응

## Scheduling Algorithm
1. FCFS(First Come First Service)
    - 선입선출. 도착시간 기준.
    - Overhead 낮음
    - Batch System에는 적합. 대화형에는 부적합
    - 평균 응답시간 길다. Convoy Effect
    - Queue
2. RR(Round Robin) - 공평성
    - Preemptive Scheduling
    - 도착 시간 기준. **자원 사용 제한 시간**있음
    - Process는 할당된 시간이 지나면 자원 반납
    - 특정 Process의 독점 방지
    - Context Switch Overhead가 큼
    - 대화형, 시분할 시스템에 적합
    - Time Quantum이 시스템 성능을 결정. 무한에 수렴하면 FCFS, 작으면 여러 프로세스가 동시에 수행되는 느낌
    - Ready-Queue에 줄 서
3. SPN(Shortest Process Next), SJF(Shortest Job First)
    - Burst time이 가장 작은 Process 먼저 처리
    - 평균 대기시간 최소화
    - 스케쥴링 부하 감소, 메모리 절약, 시스템 효율 향상
    - 빠른 응답 시간
    - Starvation 가능성. Aging으로 해결
    - 정확한 실행시간은 모름. 예측해야해
4. SRTN(Shortest Remaning Time Next)
    - SPN의 변형. 잔여 실행시간이 더 적은 프로세스 먼저
    - 구현하기 복잡
5. HRRN(High Response Ratio Next) - 효율성
    - SPN + Aging. Non-Preemptive
    - Response Ratio가 높은 프로세스 우선
    - RR = (WT + BT) / BT
    - 즉 기다릴수록 우선순위 높아짐
    - 단 여전히 BT를 예측해야하는 어려움이 있다.(어? 딥러닝 각?)
6. MLQ(Multi Level Queue) - HRRN의 어려움 개선
    - 작업 별 별도의 Ready Queue를 가짐
    - 최초 배정된 Queue를 벗어나지 못함. 각각의 Queue는 자신만의 스케줄링 사용
    - Queue 사이에 우선순위 기반 스케줄링 사용
        - 시스템 프로세스, High
        - 대화식 프로세스
        - 일괄 처리 프로세스, Low
    - 여러 개의 Queue관리로 Overhead가 큼
    - 낮은 우선순위는 여전히 Starvation의 위협을 받아
7. MFQ(Multi-Level Feedback Queue)
    - Process의 Queue간 이동 허용
    - 여러 변형이 가능(Aging 등 적용)
